%Realizado por Juan Esteban Fuentes, Laura Latorre y Duvan Santiago Matallana
classdef BP_neuronal_network
    properties
        Arquitectura          % Vector con el número de neuronas por capa [in, hn, out]
        NumCapas              % Número total de capas (incluyendo entrada y salida)
        Pesos                 % Cell array con las matrices de pesos {W1, W2, ...}
        Sesgos                % Cell array con los vectores de sesgos {b1, b2, ...}
        FuncionesActivacion   % Cell array con handles a funciones de activación {@(net)..., ...}
        DerivadasActivacion   % Cell array con handles a funciones derivadas {@(act)..., ...}
    end

    methods
        function obj = BP_neuronal_network(arquitectura, funcActivacionStr, derivActivacionStr)
            %constructor de la clase
            if nargin > 0
                obj.Arquitectura = arquitectura;
                obj.NumCapas = length(arquitectura);
                if length(funcActivacionStr) ~= obj.NumCapas -1 || length(derivActivacionStr) ~= obj.NumCapas -1
                    error('El número de funciones/derivadas debe coincidir con el número de capas ocultas + salida.');
                end
                %inicializar los pesos y sesgos (bias)
                obj.Pesos = cell(1, obj.NumCapas - 1);
                obj.Sesgos = cell(1, obj.NumCapas - 1);
                rng('shuffle'); % Inicializar generador aleatorio
                for i = 1:(obj.NumCapas-1)
                    obj.Pesos{i} = (rand(arquitectura(i+1), arquitectura(i))*2-1);
                    obj.Sesgos{i}=zeros(arquitectura(i+1),1);
                    fprintf('Capa %d: Pesos size [%d, %d], Sesgos size [%d, 1]\n', ...
                            i, size(obj.Pesos{i},1), size(obj.Pesos{i},2), size(obj.Sesgos{i},1));
                end
                %--Cambiar String de función a función handle--
                obj.FuncionesActivacion = cell(1,obj.NumCapas -1);
                obj.DerivadasActivacion = cell(1, obj.NumCapas -1);
                for i = 1:(obj.NumCapas - 1)
                    try
                        obj.FuncionesActivacion{i} = str2func(['@(net) ' funcActivacionStr{i}]);
                        obj.DerivadasActivacion{i} = str2func(['@(act) ' derivActivacionStr{i}]);
                    catch ME
                        error('Error convirtiendo string a función en capa %d: %s\nString Func: %s\nString Deriv: %s', ...
                               i, ME.message, funcActivacionStr{i}, derivActivacionStr{i});
                    end
                end
                disp('Funciones de activación y derivadas convertidas a handles.');
            end
        end    
        
        function [salidaFinal, activaciones, nets] = feedforward(obj, entrada)
            % Realiza la pasada hacia adelante (feedforward)
            % 'entrada' debe ser un vector columna
            if size(entrada, 1) ~= obj.Arquitectura(1)
                error('Dimensiones de entrada (filas=%d) no coinciden con la arquitectura (%d).', size(entrada,1), obj.Arquitectura(1));
            end
            if size(entrada, 2) ~= 1
                error('La función feedforward espera un solo patrón.')
            end
            activacion = entrada; % Activación inicial es la entrada
            activaciones = cell(1,obj.NumCapas); % Guardar activación de cada capa
            nets = cell(1,obj.NumCapas - 1); % Guardar entrada neta (z) de cada capa (excepto entrada)
            activaciones{1} = activacion;

            for i = 1:(obj.NumCapas - 1)
                W = obj.Pesos{i};
                b = obj.Sesgos{i};
                funAct = obj.FuncionesActivacion{i};

                %Calcular la entrada neta (suma ponderada Neta)
                nets{i} = W * activacion + b;

                %Calcular la activación de la neurona
                activacion = funAct(nets{i});
                activaciones{i+1} = activacion; % Guardar activación de la capa actual (i+1)
            end
            salidaFinal = activacion; % La última activación es la salida de la red
        end

        function [obj, epoca, errorFinal, historial_error, historial_pesos, historial_sesgos] = entrenar(obj, X_entrada, Y_deseada, alpha, precision, beta, axesHandle)
                        % Entrena la red usando backpropagation
            % DEVUELVE: 
            %   obj: El objeto red entrenado
            %   epoca: El número final de épocas realizadas
            %   errorFinal: El error MSE final alcanzado
            %   historial_error: Vector con el MSE de cada época
            %   historial_pesos: Cell array con los pesos de cada época
            %   historial_sesgos: Cell array con los sesgos de cada época
            % X_entrada: matriz de entradas
            % Y_deseada: matriz de salidas deseadas
            
            % --- Validaciones de Dimensiones ---
            if size(X_entrada, 1) ~= obj.Arquitectura(1)
                error('Número de características de entrada no coincide con arquitectura(%d).', size(X_entrada, 1), obj.Arquitectura(1));
            end
            if size(Y_deseada, 1) ~= obj.Arquitectura(end)
                 error('Número de características de salida no coincide con arquitectura (%d).', size(Y_deseada, 1), obj.Arquitectura(end));
            end
            numPatrones = size(X_entrada, 2);
            if size(Y_deseada, 2) ~= numPatrones
                error('Número de patrones de entrada (%d) y salida (%d) no coincide.', numPatrones, size(Y_deseada, 2));
            end

            %Validación de parámetro Beta
            if nargin < 6 % Si Beta no se proporciona
                warning('Coeficiente de Momentum (Beta) no proporcionado. Usando Beta = 0 (sin momentum).');
                beta = 0;
            elseif ~isnumeric(beta) || ~isscalar(beta) || beta < 0 || beta >= 1
                 error('Beta debe ser un escalar numérico entre 0 y 1. Valor recibido: %g', beta);
            end
            if nargin < 7 % Si axesHandle no se proporciona
                axesHandle = []; % Ponerlo vacío si no se usa
            elseif ~isempty(axesHandle) && ~isa(axesHandle, 'matlab.ui.control.UIAxes')
                warning('El handle para la gráfica no es válido. No se graficará en tiempo real.');
                axesHandle = [];
            end

            epoca = 0;  % Inicializar las épocas
            errorTotal = inf;  % Inicializar error alto
            % --- Inicializar Históricos ---
            historial_error = []; 
            historial_pesos = {}; % Cell array para guardar cell arrays de pesos
            historial_sesgos = {}; % Cell array para guardar cell arrays de sesgos
            
            % --- INICIALIZAR CAMBIOS ANTERIORES (para Momentum) ---
            delta_Pesos_prev = cell(1, obj.NumCapas - 1);
            delta_Sesgos_prev = cell(1, obj.NumCapas - 1);
            for l = 1:(obj.NumCapas - 1)
                delta_Pesos_prev{l} = zeros(size(obj.Pesos{l})); % Inicializar a cero
                delta_Sesgos_prev{l} = zeros(size(obj.Sesgos{l})); % Inicializar a cero
            end

            fprintf('\n--- Iniciando Entrenamiento ---\n');
            fprintf('Patrones: %d, Alpha: %.4f, Precisión requerida: %.g\n', numPatrones, alpha, precision);

            % --- Gráfica en Tiempo Real ---
            plotHandle = []; % Inicializar handle vacío
            if ~isempty(axesHandle) && isgraphics(axesHandle) % Comprobar si es un handle gráfico válido
                 % Limpiar ejes y obtener/crear línea de plot
                 cla(axesHandle); % Limpiar ejes existentes
                 hold(axesHandle, 'on'); % Mantener para plotear
                 plotHandle = plot(axesHandle, NaN, NaN, '-b'); % Plotear en los ejes dados
                 xlabel(axesHandle, 'Época');
                 ylabel(axesHandle, 'Error MSE/2'); 
                 title(axesHandle, 'Evolución del Error de Entrenamiento');
                 grid(axesHandle, 'on');
                 hold(axesHandle, 'off');
                 drawnow; % Mostrar figura inicial
            else
                 % Si la figura existe, obtener el handle del plot
                fig = findall(0,'Type','Figure','Tag','TrainingErrorPlot');
                ax = findall(fig, 'Type', 'Axes');
                plotHandle = findall(ax, 'Type', 'Line');
                 % Limpiar datos anteriores si se re-entrena en la misma figura
                set(plotHandle, 'XData', NaN, 'YData', NaN); 
                ylabel(ax, 'Error MSE/2');
                drawnow; 
            end
            % -----------------------------

            while errorTotal > precision
                epoca = epoca + 1;
                errorActual = 0;
                for i = 1:numPatrones
                    x = X_entrada(:,i);
                    Yd = Y_deseada(:,i);
                    
                    %Primero se realiza el feedforward
                    [Yo, activaciones, nets] = obj.feedforward(x);

                    %Cálculo del error para el patrón
                    errorPatron = Yd - Yo;
                    errorActual = errorActual + 0.5 .* sum(errorPatron.^2);
                    
                    %Backpropagation - Cálculo de deltas
                    deltas = cell(1,obj.NumCapas - 1);

                    %Delta de la capa de salida
                    activacion_salida = activaciones{end}; %Para la capa L
                    net_salida = nets{end};
                    derivadaSalida = obj.DerivadasActivacion{end}(activacion_salida);
                    deltas{end} = errorPatron .* derivadaSalida;

                    %Deltas de capas ocultas
                    for l = (obj.NumCapas - 2):-1:1  % Para cada capa l = L-1 ... 1
                        W_siguiente = obj.Pesos{l+1}; %w(l+1)
                        delta_siguiente = deltas{l+1}; %δ^(l+1)
                        activacion_l = activaciones{l+1}; % a^(l)
                        derivadaOculta = obj.DerivadasActivacion{l}(activacion_l);
                        errorPropagado = W_siguiente' * delta_siguiente; % (W^(l+1))' * δ^(l+1)
                        deltas{l} = errorPropagado .* derivadaOculta; %δ^(l)
                    end

                    %Actualización de pesos y sesgos
                    for l = 1:(obj.NumCapas - 1) % Para cada capa l (desde la 1ra oculta hasta la salida)
                        activacion_previa = activaciones{l}; % Activación de la capa anterior (a^{l-1})
                        delta_l = deltas{l};                 % Delta calculado para la capa actual δ^(l)

                        % Calcular gradientes
                        grad_W = delta_l * activacion_previa'; % Gradiente pesos W^l: (n_l x 1) * (1 x n_{l-1}) = (n_l x n_{l-1})
                        grad_b = delta_l;                      % Gradiente bias b^l: (n_l x 1)

                        %Guardar pesos para siguiente actualización:
                        pesos_a = obj.Pesos{l};
                        sesgos_a = obj.Sesgos{l};

                        % Actualizar pesos y sesgos de la capa l
                        obj.Pesos{l} = obj.Pesos{l} + alpha * grad_W + beta * (obj.Pesos{l}-delta_Pesos_prev{l});
                        obj.Sesgos{l} = obj.Sesgos{l} + alpha * grad_b + beta * (obj.Sesgos{l}-delta_Sesgos_prev{l}); 

                        % Guardar el cambio hecho para usarlo como el peso anterior en la siguiente iteración
                        delta_Pesos_prev{l} = pesos_a;
                        delta_Sesgos_prev{l} = sesgos_a;
                    end
                end
                % Calcular error total promedio de la época
                errorTotal = errorActual / numPatrones;
                % --- Guardar en Históricos (al final de la época) ---
                historial_error(epoca) = errorTotal;
                if mod(epoca, 10) == 0 || epoca == 1 % Guardar cada 10 épocas y la primera
                    historial_pesos{end+1} = obj.Pesos; % Guarda el cell array actual de pesos  
                    historial_sesgos{end+1} = obj.Sesgos; % Guarda el cell array actual de sesgos
                end
                
                % --- Actualizar Gráfica en Tiempo Real ---
                if ~isempty(plotHandle) && ishandle(plotHandle) % Solo si hay gráfica válida
                    % Actualizar datos del plot (más eficiente que plotear de nuevo)
                    set(plotHandle, 'XData', 1:epoca, 'YData', historial_error); 
                    % Ajustar límites eje X dinámicamente (opcional, puede ralentizar)
                    % parentAxes = get(plotHandle, 'Parent');
                    % xlim(parentAxes, [0 max(10, epoca + round(epoca*0.1))]); % Poner un margen
                    drawnow limitrate; % Actualizar la ventana gráfica (limitrate es más eficiente)
                end

                % Imprimir progreso
                if mod(epoca, 250) == 0 || errorTotal <= precision || epoca == 1
                  fprintf('Época: %d, Error MSE/2: %.8f\n', epoca, errorTotal);
                end
                % Condición de seguridad
                if epoca > 5000000 
                  warning('Entrenamiento detenido: Límite máximo de épocas alcanzado.');
                  break;
                end
            end
            errorFinal = errorTotal; % Guardar el último error calculado
            fprintf('\n--- Entrenamiento Finalizado ---\n');
            fprintf('Épocas totales: %d\n', epoca);
            fprintf('Error final MSE/2: %.8f\n', errorFinal);
        end

       function obj = cargarPesos(obj, filepath)
            % Carga pesos y sesgos layer-by-layer, evitando desajustes por líneas en blanco.
            if isempty(obj.Arquitectura)
                error('Debe definir Arquitectura antes de cargar pesos.');
            end
            fid = fopen(filepath,'r');
            if fid==-1
                error('No se pudo abrir "%s".', filepath);
            end
            try
                obj.Pesos = cell(1,obj.NumCapas-1);
                obj.Sesgos= cell(1,obj.NumCapas-1);
                for l = 1:obj.NumCapas-1
                    rowsW = obj.Arquitectura(l+1);
                    colsW = obj.Arquitectura(l);
                    % — leer matriz W —
                    W = zeros(rowsW, colsW);
                    for i = 1:rowsW
                        line = '';
                        % saltar líneas vacías
                        while isempty(strtrim(line))
                            line = fgetl(fid);
                            if ~ischar(line), error('Archivo inesperadamente corto.'); end
                        end
                        v = str2num(line);  %#ok<ST2NM>
                        if numel(v)~=colsW
                            error('Pesos capa %d, fila %d: esperaba %d valores, leyó %d.',l,i,colsW,numel(v));
                        end
                        W(i,:) = v;
                    end
                    obj.Pesos{l} = W;
                    % — saltar posibles líneas vacías —
                    pos = ftell(fid);
                    nxt = fgetl(fid);
                    while ischar(nxt) && isempty(strtrim(nxt))
                        pos = ftell(fid);
                        nxt = fgetl(fid);
                    end
                    fseek(fid, pos, 'bof');
                    % — leer vector b —
                    b = zeros(rowsW,1);
                    for i = 1:rowsW
                        line = fgetl(fid);
                        if ~ischar(line)
                            error('Sesgos capa %d: líneas insuficientes.',l);
                        end
                        val = str2double(strtrim(line));
                        if isnan(val)
                            error('Sesgos capa %d, fila %d: línea no numérica.', l, i);
                        end
                        b(i) = val;
                    end
                    obj.Sesgos{l} = b;
                    % ya vendrá una línea vacía o directamente la siguiente capa
                end
                fclose(fid);
                fprintf('Pesos y sesgos cargados correctamente desde "%s".\n', filepath);
            catch ME
                fclose(fid);
                rethrow(ME);
            end
        end

    

        function guardarPesos(obj, filepath)
            % Guarda los pesos y sesgos actuales de la red en un archivo de texto.
            % filepath: Ruta completa del archivo donde se guardarán los pesos.

            if isempty(obj.Pesos) || isempty(obj.Sesgos)
                 warning('No se pueden guardar los pesos: la red no parece estar inicializada o entrenada.');
                 return;
            end

            try
                fid = fopen(filepath, 'wt'); % Abrir en modo texto escritura ('wt')
                if fid == -1
                    error('No se pudo abrir el archivo "%s" para guardar los pesos.', filepath); 
                end
                % --- Bucle para escribir pesos y sesgos ---
                for l = 1:(obj.NumCapas - 1)
                    % Escribir Pesos W_l
                    W = obj.Pesos{l};
                    for r = 1:size(W, 1) % Iterar por filas de la matriz de pesos
                        fprintf(fid, '%.15g\t', W(r, :)); % Escribir elementos de la fila, separados por tabulador, alta precisión
                        fprintf(fid, '\n'); % Nueva línea al final de cada fila de pesos
                    end
                    fprintf(fid, '\n'); % Línea en blanco después de la matriz de pesos

                    % Escribir Sesgos b_l
                    b = obj.Sesgos{l};
                    for r = 1:size(b, 1) % Iterar por elementos del vector de sesgos
                         fprintf(fid, '%.15g\n', b(r)); % Escribir cada sesgo en su propia línea
                    end
                    
                    % Añadir una línea en blanco extra entre capas (excepto después de la última)
                    if l < (obj.NumCapas - 1)
                         fprintf(fid, '\n'); 
                    end
                end
                % --- Fin del bucle ---

                fclose(fid);
                % fprintf('Pesos y sesgos guardados en: "%s"\n', filepath);

            catch ME
                warning('Ocurrió un error al guardar los pesos en %s: %s', filepath, ME.message);
                if exist('fid','var') && fid ~= -1 
                    try 
                        fclose(fid); 
                    catch m
                        warning('Ocurrió un error al cerrar el archivo. %s: %s', filepath, m.message);
                    end
                end 
            end
        end

        function [ConfMatPercent, ConfMatCounts] = evaluarClasificacion(obj, X_eval, Y_eval)
            % Evalúa el rendimiento de clasificación implícito de la red.
            % Compara la salida de la red para cada entrada X_eval(:,i) 
            % con todas las salidas deseadas Y_eval(:,j) para determinar
            % cuál es la más cercana ("clasificación").
            % Devuelve una matriz de confusión en porcentajes (filas suman 100%)
            % y la matriz de confusión con conteos absolutos.
            %
            % X_eval: Matriz de entradas para evaluación (num_entradas x num_patrones)
            % Y_eval: Matriz de salidas deseadas (num_salidas x num_patrones)

            if isempty(obj.Pesos) || isempty(obj.Sesgos)
                 error('La red no parece estar inicializada o entrenada.');
            end
             if size(X_eval, 2) ~= size(Y_eval, 2)
                 error('El número de patrones de entrada y salida para evaluación no coincide.');
             end
             if size(X_eval, 1) ~= obj.Arquitectura(1) || size(Y_eval, 1) ~= obj.Arquitectura(end)
                 error('Las dimensiones de X_eval o Y_eval no coinciden con la arquitectura de la red.');
             end

            numPatronesEval = size(X_eval, 2);
            ConfMatCounts = zeros(numPatronesEval, numPatronesEval); % Filas: Patrón Real, Columnas: Patrón Predicho

            fprintf('Evaluando clasificación...\n');
            for i = 1:numPatronesEval % Para cada patrón de entrada REAL i
                x_i = X_eval(:, i);
                
                % Obtener la salida de la red para la entrada i
                Yo_i = obj.feedforward(x_i); 
                
                % Encontrar a qué salida deseada (Y_eval(:,k)) se parece más Yo_i
                distancias = zeros(1, numPatronesEval);
                for k = 1:numPatronesEval 
                    % Calcular distancia euclidiana cuadrática (más simple)
                    distancias(k) = sum((Yo_i - Y_eval(:, k)).^2);
                end
                [~, k_pred] = min(distancias); % k_pred es el índice del patrón PREDICHO

                % Incrementar la matriz de confusión
                % Fila i (real), Columna k_pred (predicha)
                ConfMatCounts(i, k_pred) = ConfMatCounts(i, k_pred) + 1;
                
                 if mod(i, 50) == 0 % Mostrar progreso
                    fprintf('Evaluado patrón %d de %d\n', i, numPatronesEval);
                 end
            end
            fprintf('Evaluación completada.\n');

            % Calcular porcentajes
            ConfMatPercent = zeros(size(ConfMatCounts));
            sumRows = sum(ConfMatCounts, 2); % Suma de cada fila (total de veces que se presentó el patrón i)
            for i = 1:numPatronesEval
                if sumRows(i) > 0
                    ConfMatPercent(i, :) = (ConfMatCounts(i, :) / sumRows(i)) * 100;
                else
                    % Si un patrón nunca se presentó (o sumRows es 0), dejar la fila en 0 o NaN
                    ConfMatPercent(i, :) = NaN; 
                    warning('El patrón de entrada %d no tuvo instancias en la suma de su fila en la matriz de confusión.', i);
                end
            end

            % Opcional: Mostrar las matrices
            disp('Matriz de Confusión (Conteos):');
            disp('(Filas: Patrón Real de Entrada, Columnas: Patrón Predicho por Salida)');
            disp(ConfMatCounts);
            
            disp('Matriz de Confusión (Porcentajes %):');
            disp('(Filas: Patrón Real de Entrada, Columnas: Patrón Predicho por Salida)');
            disp(ConfMatPercent);

        end

        function visualizarArquitectura(obj, axesHandle)
            % Dibuja una representación simple de la arquitectura en los ejes dados.
            if isempty(obj.Arquitectura) || ~isgraphics(axesHandle)
                return;
            end
            
            cla(axesHandle); % Limpiar ejes
            hold(axesHandle, 'on');
            title(axesHandle, 'Arquitectura de la Red');
            xlabel(axesHandle, 'Capa');
            ylabel(axesHandle, 'Neurona');
            
            numLayers = obj.NumCapas;
            layerNodes = obj.Arquitectura;
            
            xCoords = 1:numLayers; % Coordenada X para cada capa
            yMax = max(layerNodes); % Máximo número de nodos para escala Y
            
            nodeCoords = cell(1, numLayers);
            
            % Calcular y dibujar nodos
            for i = 1:numLayers
                numNodes = layerNodes(i);
                % Espaciar nodos verticalmente
                yCoords = linspace(0.1*yMax, 0.9*yMax, numNodes); 
                if numNodes == 1
                     yCoords = 0.5*yMax; % Centrar si hay solo 1 nodo
                end
                nodeCoords{i} = [repmat(xCoords(i), numNodes, 1), yCoords'];
                plot(axesHandle, nodeCoords{i}(:,1), nodeCoords{i}(:,2), 'o', 'MarkerSize', 10, 'MarkerFaceColor', 'b');
                text(axesHandle, nodeCoords{i}(:,1) + 0.1, nodeCoords{i}(:,2), arrayfun(@(n) sprintf('N%d', n), 1:numNodes, 'UniformOutput', false));
            end
            
            % Dibujar conexiones (líneas)
            for i = 1:(numLayers - 1)
                nodesFrom = nodeCoords{i};
                nodesTo = nodeCoords{i+1};
                for n1 = 1:size(nodesFrom, 1)
                    for n2 = 1:size(nodesTo, 1)
                        line(axesHandle, [nodesFrom(n1, 1), nodesTo(n2, 1)], [nodesFrom(n1, 2), nodesTo(n2, 2)], 'Color', [0.5 0.5 0.5]);
                    end
                end
            end
            
            xticks(axesHandle, xCoords);
            xticklabels(axesHandle, arrayfun(@(l) sprintf('Capa %d\n(%d N)', l, layerNodes(l)), 1:numLayers, 'UniformOutput', false));
            ylim(axesHandle, [0 yMax * 1.1]); % Margen superior
            set(axesHandle, 'YTick', []); % Ocultar ticks en Y
            hold(axesHandle, 'off');
        end

    end

    methods (Static)
        function config = leerConfig(filepath)
            % Inicializar estructura de configuración
            config = struct();
            if ~isfile(filepath)
                 warning('Archivo de configuración "%s" no encontrado.', filepath);
                 return;
            end
            %Leer todas las líneas del archivo
            try
                lines = readlines(filepath, "Encoding", "UTF-8"); 
            catch ME
                error('No se pudo leer el archivo de configuración "%s": %s', filepath, ME.message);
            end
            %Procesar cada línea
            for i = 1:length(lines)
                line = strtrim(lines{i}); % readlines devuelve cell array o string array
                %Ignorar líneas vacías y comentarios (usando '#')
                if isempty(line) || startsWith(line, '#') 
                    continue;
                end
                % Dividir línea en clave y valor por el PRIMER '='
                key_value = strsplit(lines{i}, '=');

                if length(key_value) < 2
                    warning('Línea mal formada (sin "="): "%s" en "%s". Ignorando.', line, filepath); 
                    continue; % Saltar línea mal formada
                end
                key = strtrim(key_value{1});
                value = strtrim(key_value{2}); % Valor inicial como string
                % Validar que la clave sea un nombre de variable válido
                if ~isvarname(key)
                     warning('Clave inválida "%s" en "%s". Ignorando.', key, filepath);
                     continue;
                end
                % 8. Convertir los valores según la clave usando switch
                try % Envuelve la conversión en try-catch para robustez
                    switch key
                        case 'ultima_arquitectura' 
                            converted_value = str2num(value); 
                            % Validar conversión de arquitectura
                            if isempty(converted_value) || ~isnumeric(converted_value) || ~isrow(converted_value)
                                error('Valor inválido o no es vector fila para arquitectura: "%s"', value);
                            end
                            config.ultima_arquitectura = converted_value;

                        case 'arquitectura'
                            converted = str2num(value);
    	                    if isempty(converted) || ~isrow(converted)
                            error('Valor inválido para arquitectura: %s', value);
                            end
                            config.ultima_arquitectura = converted;

                        case 'alpha' 
                            converted_value = str2double(value); 
                             % Validar conversión de alfa
                            if isnan(converted_value)
                                 error('Valor numérico inválido para alfa: "%s"', value);
                            end
                            config.alpha = converted_value;

                        case 'precision' 
                             converted_value = str2double(value);
                             % Validar conversión de precisión
                             if isnan(converted_value) || converted_value <= 0
                                 error('Valor inválido para la precisión (debe ser positivo): "%s"', value);
                             end
                             config.precision = converted_value; % Guardar como número

                        case 'beta'
                            converted_value = str2double(value);
                             % Validar conversión de beta
                             if isnan(converted_value) || converted_value <= 0
                                 error('Valor inválido para beta (debe ser positivo entre 0 y 1): "%s"', value);
                             end
                             config.precision = converted_value; % Guardar como número
 

                        otherwise
                            % Ignorar con advertencia (actual)
                             warning('Clave desconocida "%s" en "%s". Ignorando.', key, filepath);
                    end
                catch ME
                    % Capturar errores durante la conversión o validación
                    warning('Error procesando clave "%s" con valor "%s" en "%s": %s. Ignorando entrada.', key, value, filepath, ME.message);
                end
            end
            if ~isempty(fieldnames(config))
                fprintf('Configuración cargada desde "%s":\n', filepath);
                disp(config);
            else
                 warning('No se cargó ninguna configuración válida desde "%s".', filepath);
            end
        end

        function funciones = leerFunciones(filepath)
            % Lee las funciones (una por línea) y devuelve un cell array de strings.
            funciones = {};
            fid = fopen(filepath, 'r');
            if fid == -1
                error('No se pudo abrir el archivo de funciones: %s', filepath);
            end
            while ~feof(fid)
                line = strtrim(fgetl(fid));
                 if ~isempty(line) && ~startsWith(line, '#')
                     funciones{end+1, 1} = line;
                 end
            end
            fclose(fid);
             fprintf('Funciones cargadas desde ''%s'': %d funciones.\n', filepath, length(funciones));
        end

        function guardarConfig(path, config_struct)
            % Guarda la configuración relevante en un archivo.
            % Sobreescribe el archivo si existe.
            fid = fopen(path, 'w');
            if fid == -1
                warning('No se pudo abrir "%s" para escribir la configuración.', path);
                return;
            end
            fprintf(fid, '# Última configuración utilizada\n');
            
            if isfield(config_struct, 'alpha')
                fprintf(fid, 'alpha = %.5g\n', config_struct.alpha);
            end
            if isfield(config_struct, 'precision')
                fprintf(fid, 'precision = %.5g\n', config_struct.precision);
            end
            if isfield(config_struct, 'ultima arquitectura') % Guardar la arquitectura
                 fprintf(fid, 'última arquitectura = %s\n', mat2str(config_struct.ultima_arquitectura));
            end
            fclose(fid);
            fprintf('Configuración guardada en "%s".\n', ...
                path);
        end
    end
end